notation
  :  [infix 6];
  == != [infix 6];

data
  0 +1;

notation
  +1  [postfix 11];
  + - [infixl   8];

define
  1 == 0 +1 [rewrite];
  inf == inf +1;
  m + 0 == m;
  m + (n +1) == (m + n) +1;

notation
  not [prefix 5];
  /\  [infixr 4];
  \/  [infixr 3];
  ==> [infixr 2];
  <=> [infix  1];

eval
  let x = 1, y = 1
  in x + y;
  
  let f = (\ x -> x +1)
  in f 0;

  match 1 with
    (n +1) -> n;

inductive
  0: Nat;
  n: Nat ==> n +1: Nat;

coinductive
  0: NatInf;
  n: NatInf ==> n +1: NatInf;

assume not True;
show P;

show True;
show p <=> p;
show x == x;
show 1 == 0 +1;
show p /\ q <=> p;
show p /\ q <=> q /\ p;

assume p; p ==> q; q ==> r;
show   r;

assume x == z; p z;
show   p x;


